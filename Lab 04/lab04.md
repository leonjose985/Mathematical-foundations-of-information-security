<div style="display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100vh; text-align: center;">
  <h1><strong>Лабораторная Pабота No 4</strong></h1>
  <h2><strong>Математические Основы Защиты Информации и Информационной Безопасности</strong></h2>
  <h2>Хосе Фернандо Леон Атупанья | НФИмд-01-24</h2>
</div>

## **Содержание**

1. Цель работы
2. Выполнение лабораторной работы
3. Выводы

## **1. Цель работы**

Вычислить максимальный общий делитель, используя алгоритмы, представленные в лабораторном рабочем материале 4.


## **2. Выполнение лабораторной работы**

### Алгоритм Евклида 

В этой отчете описывается программная реализация евклида алгоритма для нахождения наибольшего общего делителя (НОД) двух чисел. Этот алгоритм, написанный на языке программирования Julia, эффективен при вычислении НОД путем итеравтиного применения операций по модулю.

Функция: Реализация алгоритма Евклида
Функция gcd вычисляет GCD из двух целых чисел, используя алгоритм Евклида. Вот краткое описание функции:

![Рис. 1: Переменные программы](./img/1.PNG)

Механизм цикла: Этот цикл while true выполняется бесконечно долго, пока не завершится при обнаружении GCD. Вычисление остатка: r_next присваивается значение r_0 % r_1, которое вычисляет остаток при делении r_0 на r_1.

Условие завершения: Цикл останавливается, когда значение r_next становится равным нулю, что означает, что значение r_1 является GCD для исходных входных данных. Этот GCD возвращается в качестве результата.

![Рис. 1: Переменные программы](./img/2.PNG)

Если значение r_next не равно нулю, значение r_0 изменяется на значение r_1, а значение r_1 изменяется на значение r_next. В этой последовательности числа уменьшаются до тех пор, пока остаток не станет равным нулю.
Результат: когда r_next равно нулю, r_1 является GCD и возвращается.

![Рис. 1: Переменные программы](./img/3.PNG)

Функция ввода предлагает пользователю ввести значения, которые затем преобразуются в целые числа.

![Рис. 1: Переменные программы](./img/4.PNG)

Пользователю предлагается ввести значение, которое хранится в a. Затем оно преобразуется в целое число num1 с помощью parse(Int, a). Аналогичным образом запрашивается другое значение, которое сохраняется в b и преобразуется в num2. 

GCD чисел num1 и num2 вычисляется с использованием функции gcd.

![Рис. 1: Переменные программы](./img/5.PNG)


Результат выводится на печать с сообщением, отображающим НОД, что на русском языке расшифровывается как GCD.

![Рис. 1: Переменные программы](./img/6.PNG)

### Бинарный алгоритм Евклида

В этом отчете описывается реализация двоичного евклидова алгоритма (также известного как алгоритм Штейна) в коде Julia для вычисления наибольшего общего делителя (НОД) двух целых чисел. Этот метод представляет собой вариацию традиционного евклидова алгоритма, использующего побитовые операции для более эффективной обработки четных и нечетных чисел.

Функция binary_gdc вычисляет GCD из двух целых чисел, используя двоичный алгоритм Евклида.

![Рис. 1: Переменные программы](./img/7.PNG)

Хотя a и b четные, они делятся на 2, а g умножается на 2, чтобы отслеживать этот коэффициент. u and v are initialized to a and b, respectively, after their even factors have been divided out.Внешний цикл продолжается до тех пор, пока u не станет равным нулю. Делаем v нечетным: этот внутренний цикл продолжает делить v на 2 до тех пор, пока v не станет нечетным.

![Рис. 1: Переменные программы](./img/8.PNG)

После того, как u и v станут нечетными, алгоритм использует вычитание для постепенного уменьшения большего значения:
Если u больше или равно v, алгоритм вычитает v из u; в противном случае он вычитает u из v.

![Рис. 1: Переменные программы](./img/9.PNG)

Как только u становится равным нулю, оставшееся значение v умножается на g (общий коэффициент 2s, удаленный ранее), чтобы получить окончательный GCD:

![Рис. 1: Переменные программы](./img/10.PNG)

Программа запускается с запроса у пользователя двух целочисленных входных данных, Вызов binary_gdc: Значение GCD для num1 и num2 вычисляется с помощью функции binary_gdc.

![Рис. 1: Переменные программы](./img/11.PNG)


Результат, обозначенный как NOD (что в переводе на русский означает НОД), отображается пользователю.

![Рис. 1: Переменные программы](./img/12.PNG)

### Расширенный алгоритм Евклида

Функция extended_euclidean является ядром этой программы. Она вычисляет как код двух целых чисел, так и коэффициенты для тождества Безу. Давайте рассмотрим каждую часть этой функции.

r0 и r1 хранят начальные значения a и b соответственно.
x0 и x1 инициализируются как 1 и 0, соответственно, представляя начальные коэффициенты для a.
y0 и y1 инициализируются как 0 и 1, представляя начальные коэффициенты для b.
i - это счетчик итераций, который не является строго необходимым для работы алгоритма, но может быть полезен для отладки или отслеживания итераций.

![Рис. 1: Переменные программы](./img/13.PNG)

На каждой итерации q вычисляется как целочисленное деление r0 на r1, представляющее, сколько раз r1 делится на r0. Следующий остаток r_next вычисляется как r0 - q * r1, что является ключевым шагом в евклидовом алгоритме для итеративного уменьшения значений до тех пор, пока остаток не достигнет нуля.

![Рис. 1: Переменные программы](./img/14.PNG)

Когда r_next равно нулю, это означает, что r1 содержит GCD из a и b. d присваивается значение r1, которое является GCD. x и y присваиваются значения x1 и y1, соответственно, представляющие собой конечные коэффициенты Безу.

![Рис. 1: Переменные программы](./img/15.PNG)

Следующие значения коэффициентов Безу вычисляются как x_next = x0 - q * x1 и y_next = y0 - q * y1. Эти значения выводятся из текущих коэффициентов и частного q, сохраняя связь x и y с исходными входными данными. 

r0 и r1 обновляются значениями r1 и r_next, постепенно приближаясь к нулевому остатку. Аналогично, x0 и x1 устанавливаются в значения x1 и x_next, а y0 и y1 обновляются до y1 и y_next. Счетчик итераций i увеличивается.

![Рис. 1: Переменные программы](./img/16.PNG)

Программа предлагает пользователю ввести два значения, a и b, которые затем преобразуются в целые числа и присваиваются числам1 и num2 соответственно. Вызов extended_euclidean: Функция вызывается с числами num1 и num2 в качестве аргументов, возвращая GCD d и коэффициенты x и y.

![Рис. 1: Переменные программы](./img/17.PNG)

Инструкция println выводит результаты на русском языке с NOD d = (БОГ) и значениями x и y, показанными в качестве коэффициентов Безу.

![Рис. 1: Переменные программы](./img/18.PNG)


### Расширенный бинанрный алгоритм Евклида

Функция binary_extended вычисляет коэффициенты GCD и Безу, используя расширенную версию алгоритма Штейна. Ниже приведена расшифровка функции:

![Рис. 1: Переменные программы](./img/19.PNG)

Удаление общих множителей, равных 2: Хотя a и b равны, они делятся на 2, а g умножается на 2, чтобы записать эти общие множители. Условие окончания цикла: Этот цикл завершается, как только значение a или b становится нечетным, удаляя все общие степени 2.

![Рис. 1: Переменные программы](./img/20.PNG)

u и v инициализируются значениями a и b.
A, B, C и D - коэффициенты для определения Безу. Первоначально, А=1, B=0, C=0, и D=1, представляющий единичную матрицу.

Внешний цикл продолжается до тех пор, пока u не станет равным нулю, что указывает на то, что НОД найден. Если A и B четные, они делятся на 2. В противном случае A и B корректируются для сохранения целочисленных значений путем добавления b к A и вычитания a из B, а затем деления обоих на 2. Аналогично, если C и D четные, они делятся на 2. В противном случае C и D корректируются таким образом, чтобы сохранить целочисленные значения, добавляя b к C и вычитая a из D.

![Рис. 1: Переменные программы](./img/21.PNG)

Затем алгоритм сравнивает u и v, чтобы уменьшить их путем вычитания, а также обновляет коэффициенты. Если u больше или равно v, v вычитается из u, а коэффициенты A и B корректируются путем вычитания C и D. И наоборот, если v больше u, u вычитается из v, а C и D обновляются путем вычитания A и B.

![Рис. 1: Переменные программы](./img/22.PNG)

Вычисление конечного коэффициента полезного действия: Коэффициент полезного действия рассчитывается путем умножения v на g, которое включает все коэффициенты из 2, разделенные ранее.

![Рис. 1: Переменные программы](./img/23.PNG)

Запрашивает у пользователя ввод данных: a и b извлекаются пользователем, сохраняются в виде строк и преобразуются в целые числа с помощью parse(Int, a) и parse(Int, b). Вызов функции binary_extended: Коэффициенты БОГА d и Безу x и y вычисляются с помощью функции binary_extended.

![Рис. 1: Переменные программы](./img/24.PNG)

## 3. Выводы

Этот проект успешно демонстрирует реализацию и применение алгоритма Евклида и его расширенных версий, включая двоичный алгоритм Евклида и расширенный двоичный алгоритм Евклида. С помощью этих реализаций мы изучили различные эффективные методы вычисления наибольшего общего делителя (GOD) двух целых чисел, а также их коэффициентов Безу. Эти коэффициенты необходимы для выражения GCD в виде линейной комбинации исходных целых чисел, которая является фундаментальной при решении линейных диофантовых уравнений и имеет практическое применение в таких областях, как криптография и модульная арифметика.



